# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T07:41:27+00:00



import argparse
import json
import os
from datetime import date
from typing import *
from typing import Optional, Union
from uuid import UUID

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, HTTPBearer
from fastapi import UploadFile
from pydantic import conint
from starlette.requests import Request

from models import (
    AccountV2,
    ApiV2AccountsIdBalancesGetResponse,
    ApiV2AccountsIdDetailsGetResponse,
    ApiV2AccountsIdGetResponse,
    ApiV2AccountsIdTransactionsGetResponse,
    ApiV2AccountsPremiumIdTransactionsGetResponse,
    ApiV2AgreementsEnduserGetResponse,
    ApiV2AgreementsEnduserIdAcceptPutResponse,
    ApiV2AgreementsEnduserIdDeleteResponse,
    ApiV2AgreementsEnduserIdGetResponse,
    ApiV2AgreementsEnduserPostResponse,
    ApiV2InstitutionsGetResponse,
    ApiV2InstitutionsGetResponse1,
    ApiV2InstitutionsIdGetResponse,
    ApiV2PaymentsAccountGetResponse,
    ApiV2PaymentsAccountGetResponse1,
    ApiV2PaymentsFieldsInstitutionIdGetResponse,
    ApiV2PaymentsGetResponse,
    ApiV2PaymentsIdDeleteResponse,
    ApiV2PaymentsIdGetResponse,
    ApiV2PaymentsPostResponse,
    ApiV2RequisitionsGetResponse,
    ApiV2RequisitionsIdDeleteResponse,
    ApiV2RequisitionsIdGetResponse,
    ApiV2RequisitionsPostResponse,
    ApiV2TokenNewPostResponse,
    ApiV2TokenRefreshPostResponse,
    CreditorAccount,
    CreditorAccountWrite,
    CreditorAccountWriteRequest,
    EnduserAcceptanceDetailsRequest,
    EndUserAgreement,
    EndUserAgreementRequest,
    Integration,
    JWTObtainPairRequest,
    JWTRefreshRequest,
    PaginatedCreditorAccountList,
    PaginatedEndUserAgreementList,
    PaginatedPaymentReadList,
    PaginatedRequisitionV2List,
    PaymentRead,
    PaymentWrite,
    PaymentWriteRequest,
    RequisitionV2,
    RequisitionV2Request,
    SpectacularJWTObtain,
    SpectacularJWTRefresh,
    SpectacularRequisitionV2,
)

app = MCPProxy(
    title='Nordigen Account Information Services API',
    version='2.0 (v2)',
    servers=[{'url': 'https://ob.nordigen.com'}],
)


@app.get(
    '/api/v2/accounts/premium/{id}/transactions/',
    description=""" Access account premium transactions. """,
    tags=['financial_institution_info'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_account_transactions_v2(
    country: Optional[str] = None,
    date_from: Optional[date] = None,
    date_to: Optional[date] = None,
    id: UUID = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v2/accounts/{id}/',
    description=""" Access account metadata.

Information about the account record, such as the processing status and IBAN.

Account status is recalculated based on the error count in the latest req. """,
    tags=['account_info_management', 'financial_institution_info'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_account_metadata(id: UUID):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v2/accounts/{id}/balances/',
    description=""" Access account balances.

Balances will be returned in Berlin Group PSD2 format. """,
    tags=['account_info_management', 'financial_institution_info'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def accounts_balances_retrieve(id: UUID):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v2/accounts/{id}/details/',
    description=""" Access account details.

Account details will be returned in Berlin Group PSD2 format. """,
    tags=['account_info_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def accounts_details_retrieve(id: UUID):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v2/accounts/{id}/transactions/',
    description=""" Access account transactions.

Transactions will be returned in Berlin Group PSD2 format. """,
    tags=['account_info_management', 'payment_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def accounts_transactions_retrieve(
    date_from: Optional[date] = None, date_to: Optional[date] = None, id: UUID = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v2/agreements/enduser/',
    description=""" Retrieve all end user agreements belonging to the company """,
    tags=['account_info_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_all__e_u_as_for_an_end_user_v2(
    limit: Optional[conint(ge=1)] = 100, offset: Optional[conint(ge=1)] = 1
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v2/agreements/enduser/',
    description=""" Create an end user agreement """,
    tags=['user_agreement_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create__e_u_a_v2(body: EndUserAgreementRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/api/v2/agreements/enduser/{id}/',
    description=""" Delete an end user agreement """,
    tags=['account_info_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete__e_u_a_by_id_v2(id: UUID):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v2/agreements/enduser/{id}/',
    description=""" Retrieve end user agreement by ID """,
    tags=['account_info_management', 'payment_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve__e_u_a_by_id_v2(id: UUID):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/api/v2/agreements/enduser/{id}/accept/',
    description=""" Accept an end-user agreement via the API """,
    tags=['user_agreement_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def accept__e_u_a(id: UUID, body: EnduserAcceptanceDetailsRequest = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v2/institutions/',
    description=""" List all available institutions """,
    tags=['financial_institution_info', 'payment_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_all_supported__institutions_in_a_given_country(
    country: Optional[str] = None, payments_enabled: Optional[str] = None
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v2/institutions/{id}/',
    description=""" Get details about a specific Institution """,
    tags=['account_info_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_institution(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v2/payments/',
    description=""" Retrieve all payments belonging to the company """,
    tags=['account_info_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_payments(
    limit: Optional[conint(ge=1)] = 100, offset: Optional[conint(ge=1)] = 1
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v2/payments/',
    description=""" Create payment """,
    tags=['payment_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_payment(body: PaymentWriteRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v2/payments/account/',
    description=""" Retrieve all payment creditor accounts """,
    tags=[
        'account_info_management',
        'user_agreement_management',
        'financial_institution_info',
        'payment_account_operations',
        'requisition_management',
        'jwt_token_handling',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_all_payment_creditor_accounts():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v2/payments/creditors/',
    description=""" API endpoints related to creditor accounts. """,
    tags=['account_info_management', 'financial_institution_info'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def payments_creditors_list(
    account: Optional[str] = None,
    address_country: Optional[str] = None,
    agent: Optional[str] = None,
    currency: Optional[str] = None,
    limit: Optional[conint(ge=1)] = 100,
    name: Optional[str] = None,
    offset: Optional[conint(ge=1)] = 1,
    type: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v2/payments/creditors/',
    description=""" API endpoints related to creditor accounts. """,
    tags=['payment_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def payments_creditors_create(body: CreditorAccountWriteRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/api/v2/payments/creditors/{id}/',
    description=""" API endpoints related to creditor accounts. """,
    tags=[
        'account_info_management',
        'user_agreement_management',
        'financial_institution_info',
        'payment_account_operations',
        'requisition_management',
        'jwt_token_handling',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def payments_creditors_destroy(id: UUID):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v2/payments/creditors/{id}/',
    description=""" API endpoints related to creditor accounts. """,
    tags=['account_info_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def payments_creditors_retrieve(id: UUID):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v2/payments/fields/{institution_id}/',
    description=""" List minimum required fields for institution """,
    tags=['financial_institution_info'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_minimum_required_fields_for_institution(institution_id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/api/v2/payments/{id}/',
    description=""" Delete periodic payment """,
    tags=[
        'account_info_management',
        'financial_institution_info',
        'payment_account_operations',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_periodic_payment(id: UUID):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v2/payments/{id}/',
    description=""" Retrieve payment """,
    tags=['account_info_management', 'payment_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_payment(id: UUID):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v2/requisitions/',
    description=""" Retrieve all requisitions belonging to the company """,
    tags=['financial_institution_info'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_all_requisitions(
    limit: Optional[conint(ge=1)] = 100, offset: Optional[conint(ge=1)] = 1
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v2/requisitions/',
    description=""" Create a new requisition """,
    tags=['requisition_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def requisition_created(body: RequisitionV2Request):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/api/v2/requisitions/{id}/',
    description=""" Delete requisition and its end user agreement """,
    tags=[
        'account_info_management',
        'financial_institution_info',
        'payment_account_operations',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_requisition_by_id_v2(id: UUID):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v2/requisitions/{id}/',
    description=""" Retrieve a requisition by ID """,
    tags=['account_info_management', 'payment_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def requisition_by_id(id: UUID):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v2/token/new/',
    description=""" Obtain JWT pair """,
    tags=['jwt_token_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def j_w_t__obtain(body: JWTObtainPairRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v2/token/refresh/',
    description=""" Refresh access token """,
    tags=['jwt_token_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def j_w_t__refresh(body: JWTRefreshRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
